import { Injectable, NotFoundException, ForbiddenException, BadRequestException, Inject } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { ProviderSite, ProfileStatus } from '@prisma/client';
import { TalkyTimesProvider } from '../providers/talkytimes/talkytimes.provider';
import { TALKY_TIMES_PROVIDER } from '../providers/providers.module';
import { EncryptionService } from '../common/encryption/encryption.service';
import { TalkyTimesSessionService } from '../providers/talkytimes/session.service';



@Injectable()
export class ProfilesService {
	constructor(
		private readonly prisma: PrismaService,
		@Inject(TALKY_TIMES_PROVIDER) private readonly talkyTimesProvider: TalkyTimesProvider,
		private readonly encryption: EncryptionService,
		private readonly sessionService: TalkyTimesSessionService
	) {}

	async create(params: { groupId: string; provider: ProviderSite; displayName?: string; credentialLogin?: string; credentialPassword?: string }, agencyCode: string) {
		const { groupId, provider, displayName, credentialLogin, credentialPassword } = params;
		
		// –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —â–æ –≥—Ä—É–ø–∞ –Ω–∞–ª–µ–∂–∏—Ç—å –¥–æ –∞–≥–µ–Ω—Ü—ñ—ó
		const group = await this.prisma.group.findFirst({
			where: { id: groupId, agency: { code: agencyCode } }
		});
		
		if (!group) {
			throw new NotFoundException('Group not found');
		}

		// –í–∞–ª—ñ–¥–∞—Ü—ñ—è –æ–±–ª—ñ–∫–æ–≤–∏—Ö –¥–∞–Ω–∏—Ö –¥–ª—è TalkyTimes
		let platformProfileId: string | undefined;
		if (provider === ProviderSite.TALKYTIMES && credentialLogin && credentialPassword) {
			const validation = await this.talkyTimesProvider.validateCredentials(credentialLogin, credentialPassword);
			if (!validation.success) {
				throw new BadRequestException(`–ù–µ –≤–¥–∞–ª–æ—Å—å –∑–∞–ª–æ–≥—ñ–Ω–∏—Ç–∏—Å—å –Ω–∞ TalkyTimes: ${validation.error || '–ù–µ–≤—ñ—Ä–Ω—ñ –æ–±–ª—ñ–∫–æ–≤—ñ –¥–∞–Ω—ñ'}`);
			}
			platformProfileId = validation.profileId;
		}

		// –ì–µ–Ω–µ—Ä—É—î–º–æ —É–Ω—ñ–∫–∞–ª—å–Ω–∏–π externalId –¥–ª—è –ø—Ä–æ—Ñ—ñ–ª—é
		const externalId = `${provider.toLowerCase()}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

		return this.prisma.profile.create({
			data: {
				groupId,
				provider,
				externalId,
				displayName,
				credentialLogin,
				credentialPassword: this.encryption.encrypt(credentialPassword),
				profileId: platformProfileId,
				status: ProfileStatus.ACTIVE,
			},
			include: {
				group: true
			}
		});
	}

	listByGroup(groupId: string) {
		return this.prisma.profile.findMany({ 
			where: { groupId },
			include: { group: true }
		});
	}

	listByAgencyCode(agencyCode: string) {
		return this.prisma.profile.findMany({
			where: {
				group: {
					agency: { code: agencyCode }
				}
			},
			include: {
				group: true
			},
			orderBy: { createdAt: 'desc' }
		});
	}

	async listByOperatorAccess(operatorId: string, agencyCode: string) {
		// –û—Ç—Ä–∏–º—É—î–º–æ –ø—Ä–æ—Ñ—ñ–ª—ñ –∑ –≥—Ä—É–ø, –¥–æ —è–∫–∏—Ö –º–∞—î –¥–æ—Å—Ç—É–ø –æ–ø–µ—Ä–∞—Ç–æ—Ä
		return this.prisma.profile.findMany({
			where: {
				group: {
					agency: { code: agencyCode },
					operators: {
						some: {
							operatorId: operatorId
						}
					}
				}
			},
			include: {
				group: true
			},
			orderBy: { createdAt: 'desc' }
		});
	}

	async hasAccessToProfile(profileId: string, operatorId: string, agencyCode: string): Promise<boolean> {
		const profile = await this.prisma.profile.findFirst({
			where: {
				id: profileId,
				group: {
					agency: { code: agencyCode },
					operators: {
						some: {
							operatorId: operatorId
						}
					}
				}
			}
		});
		return !!profile;
	}

	async update(profileId: string, updates: { displayName?: string; credentialLogin?: string; credentialPassword?: string; groupId?: string }, agencyCode: string) {
		// –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —â–æ –ø—Ä–æ—Ñ—ñ–ª—å –Ω–∞–ª–µ–∂–∏—Ç—å –¥–æ –∞–≥–µ–Ω—Ü—ñ—ó
		const profile = await this.prisma.profile.findFirst({
			where: {
				id: profileId,
				group: { agency: { code: agencyCode } }
			}
		});

		if (!profile) {
			throw new NotFoundException('Profile not found');
		}

		const updateData: any = {};

		if (updates.displayName !== undefined) {
			updateData.displayName = updates.displayName;
		}
		if (updates.credentialLogin !== undefined) {
			updateData.credentialLogin = updates.credentialLogin;
		}
		if (updates.credentialPassword !== undefined) {
			updateData.credentialPassword = this.encryption.encrypt(updates.credentialPassword);
		}
		if (updates.groupId) {
			// –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —â–æ –Ω–æ–≤–∞ –≥—Ä—É–ø–∞ —Ç–∞–∫–æ–∂ –Ω–∞–ª–µ–∂–∏—Ç—å –¥–æ –∞–≥–µ–Ω—Ü—ñ—ó
			const newGroup = await this.prisma.group.findFirst({
				where: { id: updates.groupId, agency: { code: agencyCode } }
			});
			if (!newGroup) {
				throw new NotFoundException('New group not found');
			}
			updateData.groupId = updates.groupId;
		}

		return this.prisma.profile.update({
			where: { id: profileId },
			data: updateData,
			include: { group: true }
		});
	}

	async delete(profileId: string, agencyCode: string) {
		// –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —â–æ –ø—Ä–æ—Ñ—ñ–ª—å –Ω–∞–ª–µ–∂–∏—Ç—å –¥–æ –∞–≥–µ–Ω—Ü—ñ—ó
		const profile = await this.prisma.profile.findFirst({
			where: {
				id: profileId,
				group: { agency: { code: agencyCode } }
			}
		});

		if (!profile) {
			throw new NotFoundException('Profile not found');
		}

		return this.prisma.profile.delete({
			where: { id: profileId }
		});
	}

	async authenticateProfile(profileId: string, password: string, agencyCode: string) {
		console.log(`üîê Authenticating profile ${profileId} with agencyCode ${agencyCode}`);
		
		// –ó–Ω–∞—Ö–æ–¥–∏–º–æ –ø—Ä–æ—Ñ—ñ–ª—å
		const profile = await this.prisma.profile.findFirst({
			where: {
				id: profileId,
				group: {
					agency: { code: agencyCode }
				}
			}
		});

		if (!profile) {
			console.log(`‚ùå Profile ${profileId} not found for agency ${agencyCode}`);
			throw new NotFoundException('Profile not found');
		}
		
		console.log(`‚úÖ Profile found: ${profile.displayName}, credentialLogin: ${profile.credentialLogin}`);

		// –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —â–æ —î –æ–±–ª—ñ–∫–æ–≤—ñ –¥–∞–Ω—ñ
		if (!profile.credentialPassword || !profile.credentialLogin) {
			throw new BadRequestException('Profile credentials not found');
		}

		// –†–æ–∑—à–∏—Ñ—Ä–æ–≤—É—î–º–æ –ø–∞—Ä–æ–ª—å
		const decryptedPassword = this.encryption.decrypt(profile.credentialPassword);
		console.log(`üîì Decrypted password matches provided: ${decryptedPassword === password}`);
		
		// –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –ø–∞—Ä–æ–ª—å
		if (decryptedPassword !== password) {
			console.log(`‚ùå Password mismatch for profile ${profileId}`);
			throw new BadRequestException('Invalid password');
		}

		// –ê–≤—Ç–µ–Ω—Ç–∏—Ñ—ñ–∫—É—î–º–æ –ø—Ä–æ—Ñ—ñ–ª—å —á–µ—Ä–µ–∑ –ø—Ä–æ–≤–∞–π–¥–µ—Ä
		console.log(`üöÄ Calling TalkyTimes validateCredentials for ${profile.credentialLogin}`);
		const result = await this.talkyTimesProvider.validateCredentials(profile.credentialLogin, password);
		
		console.log(`üì• TalkyTimes auth result:`, { success: result.success, error: result.error, profileId: result.profileId });
		
		if (!result.success) {
			console.log(`‚ùå TalkyTimes authentication failed: ${result.error}`);
			throw new BadRequestException(result.error || 'Authentication failed');
		}

		// –û–Ω–æ–≤–ª—é—î–º–æ –ø—Ä–æ—Ñ—ñ–ª—å –∑ –Ω–æ–≤–∏–º profileId —è–∫—â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ
		if (result.profileId && result.profileId !== profile.profileId) {
			console.log(`üîÑ Updating profileId from ${profile.profileId} to ${result.profileId}`);
			await this.prisma.profile.update({
				where: { id: profileId },
				data: { profileId: result.profileId }
			});
		}

		console.log(`‚úÖ Profile authenticated successfully: ${result.profileId || profile.profileId}`);
		return {
			success: true,
			profileId: result.profileId || profile.profileId,
			message: 'Profile authenticated successfully'
		};
	}

	async getProfileSessionStatus(profileId: string, agencyCode: string) {
		// –ó–Ω–∞—Ö–æ–¥–∏–º–æ –ø—Ä–æ—Ñ—ñ–ª—å
		const profile = await this.prisma.profile.findFirst({
			where: {
				id: profileId,
				group: {
					agency: { code: agencyCode }
				}
			}
		});

		if (!profile) {
			throw new NotFoundException('Profile not found');
		}

		if (!profile.profileId) {
			return {
				authenticated: false,
				message: 'Profile not authenticated'
			};
		}

		// –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Å—Ç–∞—Ç—É—Å —Å–µ—Å—ñ—ó
		const isValid = await this.sessionService.validateSession(profile.profileId);
		
		return {
			authenticated: isValid,
			profileId: profile.profileId,
			message: isValid ? 'Session is active' : 'Session expired'
		};
	}

	async getProfileData(profileId: string, agencyCode: string) {
		const profile = await this.prisma.profile.findFirst({
			where: { id: profileId, group: { agency: { code: agencyCode } } }
		});

		if (!profile || !profile.profileId) {
			return { success: false, error: 'Profile not found or not authenticated' };
		}

		if (!this.talkyTimesProvider.fetchProfileData) {
			return { success: false, error: 'Profile data fetching not supported' };
		}

		return this.talkyTimesProvider.fetchProfileData(profile.profileId);
	}

	async getGiftLimits(profileId: string, clientId: number, agencyCode: string) {
		console.log(`üéÅ Getting gift limits for profile ${profileId}, client ${clientId}, agency ${agencyCode}`);

		const profile = await this.prisma.profile.findFirst({
			where: {
				id: profileId,
				group: {
					agency: { code: agencyCode }
				}
			}
		});

		if (!profile) {
			throw new NotFoundException('Profile not found');
		}

		if (!profile.profileId) {
			throw new BadRequestException('Profile not authenticated');
		}

		// –í–∏–∫–ª–∏–∫–∞—î–º–æ –º–µ—Ç–æ–¥ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –ª—ñ–º—ñ—Ç—ñ–≤ –∑ TalkyTimes –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
		return this.talkyTimesProvider.getVirtualGiftLimits(profile.profileId, clientId);
	}

	async getGiftList(profileId: string, clientId: number, cursor: string = '', limit: number = 30, agencyCode: string) {
		console.log(`üéÅ Getting gift list for profile ${profileId}, client ${clientId}, cursor=${cursor}, limit=${limit}, agency ${agencyCode}`);

		const profile = await this.prisma.profile.findFirst({
			where: {
				id: profileId,
				group: {
					agency: { code: agencyCode }
				}
			}
		});

		if (!profile) {
			throw new NotFoundException('Profile not found');
		}

		if (!profile.profileId) {
			throw new BadRequestException('Profile not authenticated');
		}

		// –í–∏–∫–ª–∏–∫–∞—î–º–æ –º–µ—Ç–æ–¥ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Å–ø–∏—Å–∫—É –ø–æ–¥–∞—Ä—É–Ω–∫—ñ–≤ –∑ TalkyTimes –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
		const result = await this.talkyTimesProvider.getVirtualGiftList(profile.profileId, clientId, cursor, limit);

		// –õ–æ–≥—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
		if (result.success && result.data) {
			console.log(`üéÅ ProfilesService returning ${result.data.items?.length || 0} gifts`);
			result.data.items?.slice(0, 2).forEach((item, index) => {
				console.log(`üéÅ Gift ${index + 1}: ${item.name}, imageSrc: ${item.imageSrc}`);
			});
		}

		return result;
	}

	async sendGift(profileId: string, clientId: number, giftId: number, message: string = '', agencyCode: string) {
		console.log(`üéÅ Sending gift ${giftId} from profile ${profileId} to client ${clientId}, message: "${message}"`);

		const profile = await this.prisma.profile.findFirst({
			where: {
				id: profileId,
				group: {
					agency: { code: agencyCode }
				}
			}
		});

		if (!profile) {
			throw new NotFoundException('Profile not found');
		}

		if (!profile.profileId) {
			throw new BadRequestException('Profile not authenticated');
		}

		const result = await this.talkyTimesProvider.sendVirtualGift(profile.profileId, clientId, giftId, message);

		console.log(`üéÅ Gift send result:`, result);
		return result;
	}
}
